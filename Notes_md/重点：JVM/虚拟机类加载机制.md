# 虚拟机类加载机制
* 类加载的过程都是在运行期间完成的
## 1. 类加载的时机
### 1.1 类的生命周期
1. 加载
2. 连接
    1. 验证
    2. 准备
    3. 解析
3. 初始化
4. 使用
5. 卸载
### 1.2 类初始化的契机
* 主动引用
    1. 遇到new（new创建对象）、getstatic（读取静态变量）、putstatic（设置静态变量）或invokestatic（调用静态方法）这四条字节码指令时
    2. 反射的时候
    3. 初始化子类，需先初始化父类
    4. 指定的唯一要执行的主类（main方法的类）
    5. 使用动态语言支持
* 被动引用
    其他情况全是被动引用
## 2. 类加载过程
### 2.1 加载
1. 通过全限定类名获取二进制字节流
2. 将字节流代表的静态存储结构转化为方法区的运行时数据结构
3. 在内存中创建类的java.lang.Class对象（HotSpot存于方法区）
### 2.2 链接
* 验证
    1. 文件格式验证
         验证是否符合class文件格式的规范
    2. 元数据验证
        保证符合java语言规范，对数据类型进行验证
    3. 字节码验证
        分析程序语义，对类的方法体进行验证
    4. 符号引用验证
        对常量池中符号引用进行匹配验证，确保解析动作能正常执行
* 准备
    * 为类的静态变量分配内存并设置默认初始值（如int的0）
* 解析
    * 将常量池中的符号引用替换成直接引用
### 2.3 初始化
* 完成静态变量的真正初值的设置
## 3. 类加载过程
* 作用：通过一个类的全限定类名获取类的二进制字节流
* 类的唯一性由类加载器和类本身决定，不同加载器加载同一个class文件也不是一个类
* 过程
    * 扯淡版：
    要加载一个类
    1、看看有没有现成的
    2、没有就让他爹去看，他爹又让他爹，直到没爹
    3、某一辈找着了，加载，返回
    4、老一辈没找着，就让低辈还是靠自己吧
    5、如果新一辈找着了，皆大欢喜，加载，返回
    6、新一辈没找着，完蛋了只能告诉你我不行了，抛出了ClassNotFoundException
### 3.1 加载器分类
* 启动类加载器（Bootstrap ClassLoader）
    * 加载<JAVA_HOME>\lib目录下的类
* 扩展类加载器（Extension ClassLoader）
    * 加载<JAVA_HOME>\lib\ext目录下的类
* 应用程序类加载器（Application ClassLoader）
    * 加载普通类
* 用户类加载器（User ClassLoader）
    * 用户自定义的类加载器
### 3.2 类加载机制
全盘负责：这类我找着了，这个类的老爹啥的类也交给我吧
双亲委派：有事老爹顶着，老爹的老爹顶着，他们顶不住再交给下一辈
缓存机制：祖祖辈辈加载的类都得保存好呀，这可是遗产



​    