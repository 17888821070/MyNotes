# 垃圾回收器

## 1. 如何判断垃圾？

### 1.1 引用计数法

* 描述：对象持有一个计数器，被引用时计数+1，引用失效时计数-1，如果对象的计数为0表示对象是垃圾

* 缺点：对象循环引用时会导致对象无法回收

  ```java
  //循环引用例子
  //A对象引用B对象，B对象引用A对象
  class A{
      public B b;
  }
  class B{
      public A a;
  }
  
  main(){
      A a_ = new A();
      B b_ = new B();
      a_.b = b_;
      b_.a = a_;
      a_=null;
      b_=null;
  }
  ```

### 1.2 可达性分析法

* 描述：维护一些一GCRoots为根节点的引用树，从GCRoots到对象的路径叫引用链，如果找不到某个对象的引用链，那这个对象就是垃圾对象

#### 1.2.1 可以作为GCRoots的对象

1. 方法区的静态对象
2. 方法区的常量
3. java栈的局部变量表中的对象
4. 本地方法栈中的Native引用对象

#### 1.2.2 对象被判定为垃圾后的自救

* 描述：
  * 对象在经过可达性分析后没有找到引用链后，第一次标记为垃圾对象；此时进行一次筛选，此对象是否有必要执行他的finalize()方法，（有必要：覆写了finalize方法，并且没执过），如果finalize()方法中将对象重新连接到引用链上，则移除准备回收的标记
* 注意：
    * finalize()方法只能执行一次，所以只能自救一次
    * finalize()是对象逃离死亡命运的最后一次机会

### 1.3 引用类型

* 强引用（我必须活着）
  * 普遍存在的对象，如new出来的对象，只要强引用还在，垃圾收集器就不会回收被引用的对象
* 软引用（非必要时刻，让我活着）
  * 有用但并不是必须的，在系统将要发生内存溢出时会对被软引用的对象进行回收，如果还不够才会报内存溢出异常，使用
* 弱引用（看见就干掉）
  * 描述非必须对象，存活到下次垃圾收集的时候，垃圾回收时不管内存是否足够都会将只有弱引用的对象回收，使用，使用WeakReference实现
* 虚引用（我没什么用，当我不存在）
  * 最弱的引用，不会对对象回收造成影响，没有别的引用的话，就相当于没有引用，作用是在此对象被回收时得到一个系统通知，PhantomReference实现

### 1.4 方法区的垃圾判定方法

* 运行时常量池
  * 没有对象持有常量池中常量的引用，则为垃圾
* 类卸载
  1. 类的实例没有了（个人猜测：就是方法头中没有人持有类Class对象的引用了）
  2. 加载该类的ClassLoader已被回收
  3. 类的Class对象没有被引用（防止反射需要类Class对象信息却找不到）

## 2. 垃圾收集

### 2.1 垃圾收集时机

1. 根节点枚举
   * 使用OomMap数据结构对GCRoots进行枚举，存于内存中，需要GC时根据OopMap就能获取到GCRoots
2. 安全点
   * 在一定指令间隔设置一个SafePoint，所有线程到达SafePoint时可以通过OopMap获取到GCRoots
   * 抢先式触发：GC需要回收时，中断所有线程，再放行没有到达SafePoint的线程到SafePoint点，进行GC。不常用
   * 主动式触发：GC需要回收时，设置一个表示位。各个线程轮询检查此标志位，判断要GC后，运行到下一次SafePoint就暂停线程。
3. 安全区域
   * 在某些线程阻塞的时候是没办法运行到SafePoint的，但此时阻塞的线程也不会引起堆内存的变化。
   * 针对此种情况设定一个安全区，线程进入这种状态的时候标记自己进入了安全区（Safe Region），处于Region的线程跟进入了SafePoint的线程一样。

### 2.2 垃圾回收算法

#### 2.2.1 标记清除法

* 描述：标记垃圾、清除垃圾
* 缺点：产生大量碎片化内存空间，标记和清除效率都不高

#### 2.2.2 复制法

* 描述：将堆内存分成两部分，一部分一直不存对象，当另一部分满了之后，将存活的对象复制到另一块上，清空满的那块
* 缺点：有一半内存不存对象，十分浪费内存空间
* 说明：商用虚拟机都使用此种方法回收新生代（新生代分为Eden和From Survivor和To Survivor，当Eden满了，将Eden和From Suivivor中存活的复制到To Suivivor，清除Eden和From Survivor，From Survivor和To Survivor调换）

#### 2.2.3 标记整理法

* 描述：标记垃圾、向一端整理存活对象，清除边界外的对象
* 缺点：慢
* 说明：用于老年代的垃圾回收

#### 2.2.4 分代收集法

* 描述：将内存分为多个四个区域，新生代（Eden，From Survivor，To Survivor）和老年代，新生代使用复制算法，将Eden和From Suivivor中存活的复制到To Suivivor，清除Eden和From Survivor，From Survivor和To Survivor调换，如果To Suivivor存放存活对象存不下，直接存到老年代。老年代使用标记清除或者标记整理法处理

### 2.3 垃圾收集器

**新生代：**

#### 2.3.1 Serial收集器（串行收集器）

* 描述：最基本的收集器，进行垃圾回收时，必须暂停其他所有的工作线程，直到收集结束
* 回收过程：
    *  Serial在新生代收集时，暂停所有线程，使用复制法完成垃圾收集回收，恢复线程
    * SerialOld在老年代收集时，暂停所有线程，使用标记整理法完成垃圾收集回收，恢复线程
* 优点：对于运行在Client模式下的虚拟机来说是很好的选择，（停顿时间短可以接受）

#### 2.3.2 Per New收集器

* 描述：Serial收集器的的多线程版本，垃圾回收时暂停所有线程
* 回收过程
    * ParNew在新生代收集时，暂停所有线程，使用复制法完成垃圾收集回收（多线程操作），恢复线程
    * ParNew Old在老年代收集时，暂停所有线程，使用标记整理法完成垃圾收集回收（多线程操作），恢复线程
* 优点：能与CMS收集器合作使用，且在多CPU情况下比Serial快速

#### 2.3.3 Parallel Scavenge 收集器

* 描述：与ParNew类似，并行、使用复制算法、多线程，但关注点不同，Parallel Scavenge关注吞吐量（高效的利用CPU）
* 回收过程
    * 新生代复制、老年代标记整理
* 优点：CPU利用率高，适用于后台运算，不需太多交互的任务

**老年代：**

#### 2.3.4 Serial Old收集器

* 描述：Serial收集器的老年代版本
* 回收过程
    * 使用标记整理方式回收
* 使用场景：主要用于Client模式下的虚拟机

#### 2.3.5 Parallel Old收集器

* 描述：Parallel Scavenge收集器的老年代版本，使用多线程和标记整理法
* 优点：搭配Parallel Scanvenge收集器使用，实现对吞吐量的优先组合

#### 2.3.6 CMS收集器

* 描述：Concurrent Mark Sweep，以获取最短回收停顿时间为目标的收集器
* 使用场景：用户交互频繁，要求快速响应的情况
* 回收过程
    * 初始标记（Strop the world）
        * 暂停所有其他线程，对直接与GCRoots相连的对象进行标记，速度很快
    * 并发标记（与用户线程并发）
        * 与其他线程并发进行，记录可达对象，此部分无法保证所有对象被标记，因为此部分是并发进行的，此阶段可能用户线程又修改了对象引用，但会记录引用更新的地方
    * 重新标记（Strop the world）
        * 暂停所有线程，对并发标记期间修改的引用进行可达性分析，进行标记，此部分时间比初始标记长，比并发标记短
    * 并发清除（与用户线程并发）
        * 开启用户线程，对标记过的区域进行清扫
* 优点：并发、低停顿
* 缺点：
    1. 对CPU资源非常敏感
    2. 无法处理浮动垃圾，在并发清理期间产生的垃圾需要在下一次垃圾收集时清理
    3. 使用了标记清除方式收集垃圾，有碎片空间产生

**新老年代自己干:**

#### 2.3.7 G1收集器

* 回收过程：
    * 将堆分成多个大小相等的独立区域Region，跟踪各个Region的价值（回收得到的空间和需要的时间的经验值），每次根据允许收集时间优先回收价值最大的Region，保证了有限时间内尽可能高的收集效率
    * 步骤：
        * 初始标记（Stop the world）
            * 标记与GCRoots直接相连的对象，很快
        * 并发标记（与用户线程并发运行）
            * 并发标记可达对象
        * 最终标记（Stop the world）
            * 暂停所有线程，将并发标记部分更新的引用进行标记
        * 筛选回收（Stop the world）
            * 暂停所有线程（非必须），对Region价值排序，按照用户设定的回收计划对Region回收
* 优点
    1. 并行与并发：缩短了stop-the-world的时间
    2. 分代收集：能够处理新生代和老年代的垃圾，能够以不同的方式处理新对象，熬过几次GC得旧对象
    3. 空间整合：整体上看使用了标记整理算法，局部采用复制算法，防止空间碎片化
    4. 可预测的停顿：可以指定在M时间内，不能在垃圾收集上消耗超过N

## 3. 内存分配与回收策略

### 3.1 内存分配原则

1. 对象优先分配在Eden
   * 新创建的对象优先进入Eden区，Eden区空间不够时，发起一次Minor GC
* 大对象直接进入老年代
    * 大对象例如大数组，直接进入老年代，老年代空间不够时，发起一次Major GC
* 长期存活的对象进入老年代
    * 经过多次minor GC，并存活的对象，超过设定的年龄的对象进入老年代，默认15岁
* Survivor中年龄相同对象超过内存一半，大于等于此年龄的进入老年代
    * 如果Survivor区汇中年龄相同的对象超过了Survivor内存的一半，则无视年龄，将大于或等于此年龄的对象放入老年代

### 3.2 分代收集策略的具体回收流程

* 相关概念
  * 新生代收集：minor GC
    * 频繁且快速
  * 老年代收集：Major GC/ full GC
    * 慢，常伴随一次minor GC
  * 对象存活年龄
    * 新生代中的对象每经过一次minor GC，就涨了一岁
* 流程：
  1. 将堆内存分为多个四个区域，新生代（Eden，From Survivor，To Survivor）和老年代
  2. 新生代使用复制算法，将Eden和From Suivivor中存活的复制到To Suivivor，清除Eden和From Survivor，From Survivor和To Survivor调换（一次 minor GC，存活下来的对象年龄+1）
  3. 如果To Suivivor存放存活对象存不下，直接存到老年代
  4. 老年代放不下新生代交过来的对象时，发生full GC

### 3.3 空间分配担保
* minor GC之前，判断老年代空间是否大于新生代所有对象总和（是则minor GC），判断参数是否允许担保失败并且老年代空间是否大于历次计入老年代的对象的平均值（是则minor GC），否则发起Major GC