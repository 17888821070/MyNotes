

# Java内存区域与内存溢出异常

## 1. 运行时数据区
### 1.1 程序计数器

* 大小
  * 一块很小的内存空间
* 作用
  * 当前线程所执行的字节码的行号指示器，通过改变这个计数器的值选取下一条需要执行的字节码指令
  * 分支、循环、跳转、异常处理、线程恢复都需要这个计数器来完成
* 生命周期
  * 随线程
* 存储内容
  * 下一条需要运行的字节码指令
* 异常
  * 此部分没有指定异常

### 1.2 Java栈

* 作用
  * 描述方法的内存模型，一个方法的执行与结束对应着java栈中一个栈帧的入栈和出栈
* 生命周期
  * 随线程
* 存储内容
  * 栈帧：一个java方法，对应一个栈帧
    * 局部变量表：存储this、方法参数、局部变量，使用slot槽作为存储单位，long和double占用两个槽，引用类型变量存储的是对象在堆中的地址，如果使用对象调用方法时会将this放在第一个槽，局部变量表从入栈时就确定了大小
    * 操作数栈：在方法计算时，通过将局部变量入栈、计算、出栈实现局部变量表数据的修改
    * 动态链接：存储运行时常量池中类、方法的动态链接，运行到此时可能会跳转到其他方法，令新方法入栈
    * 方法出口：存储返回值地址
* 异常
  * OutOfMemmoryError：java虚拟机栈动态扩展申请不到内存时报错
  * StackOverFlowError：方法请求深度大于虚拟机所允许的深度时报错

### 1.3 本地方法栈

* 作用
   执行Native本地方法
* 生命周期
    线程私有，随着线程产生和死亡
* 异常
    OutOfMemoryError    
    StackOverFlowError

### 1.4 Java堆

* 大小
  * 最大的一块
* 作用
  * 存放对象的实例对象和数组，是垃圾收集器管理的主要区域，物理上不连续，逻辑上连续
* 生命周期
  * 线程共享，虚拟机启动时创建
* 存储内容
  * 对象实例、数组
* 异常
  * OutOfMemoryError：堆中没有内容完成实例分配，且堆无法扩展时抛出

### 1.5 方法区

 * 作用
   	* 存储方法类信息（类的Class对象，常量，静态变量，即时编译器编译后的代码），此部分垃圾回收主要是针对常量池和类的卸载
 * 生命周期
   	* 线程共享，虚拟机启动时创建
 * 存储内容
   	* 类信息（Class对象，常量，静态变量，即时编译器、运行时常量池）

#### 1.5.1 运行时常量池

* 作用
  * 方法区的一部分，用于存储编译器生成的各种字面量和符号引用

## 2. 对象和虚拟机

### 2.1 new对应虚拟机的操作

1. **类加载检查**：检查运行时常量池中能否对应到类的符号引用，并检查类是否已加载，没有则进行类加载
2. 为新生对象**分配内存**
    1. 如果堆内存规整（一边内存已用，一边内存未用，中间用指针划分），采用指针碰撞方法分配，直接将指针移动对象大小的位置
    2. 如果堆内存不规整（内存已用和未用区间不连续，维护列表记录未使用区域），采用空闲列表方法分配，查找链表将合适大小的内存分配给新生对象
    扩展：是否规整由垃圾收集器是否具有压缩整理功能决定，Serial、ParNew使用指针碰撞，CMS采用空闲列表
    3. TLAB，为防止多个线程将一块内存同时分配给不同的对象，造成线程安全问题。采用本地线程分配缓存——TLAB（Thread Local Allocation Buffer），每个线程在堆中预先分配一小块内存，只有在TLAB用完需要再分配时需要同步锁定
3. 分配完成后将分配的内存空间都**初始化为零值**（如int的零值是0，引用类型的零值是null）
4. **设置对象头**
5. 对象初始化<Init>，内存空间数据设置为new**设置的初值**

### 2.2 对象的内存布局

1. 对象头

	* 内容：hashCode、GC分代年龄、锁状态标志、线程持有的锁、偏向线程id、偏向时间戳、类型指针（虚拟机通过此部分确定对象属于的类）	

2. 实例数据

	* 本类及父类的基本类型数据和引用类型数据指针

3. 对齐填充

	* HotSpot要求对象实例的大小是8字节的整数倍，对象头是8或者16字节，实例数据有可能不是，需要补充字节使总数为8的倍数，起到占位的作用

### 2.3 对象的访问定位

* 使用句柄
    * 堆中划分出一块内存作为句柄池，栈中引用指向句柄指针，句柄包含指向堆中实例数据的指针和指向对象的具体类型的指针
    * 好处：堆中对象位置调整时，只需要改变句柄中的对象指针
* 直接定位
    * 栈中引用直接指向堆中对象头的地址，堆中实例对象的对象头中包含对象的类型数据
    * 好处：减少了一次指针定位的开销，速度更快

## 3. 内存溢出异常 OutOfMemoryError
### 3.1 Java堆溢出
一直new直到超过了设置的堆没有内存可分配给对象
### 3.2 虚拟机栈和本地方法栈溢出
虚拟机在扩展栈时无法审定到足够的内存空间
举例：死循环创建线程，每个线程的run方法执行死循环代码
测试的时候导致电脑假死了
### 3.3 方法区和运行常量池溢出
动态生成类，造成方法区没有内存空间存储新的类信息
向运行时常量池加入常量，直到没有区间分配给新的常量