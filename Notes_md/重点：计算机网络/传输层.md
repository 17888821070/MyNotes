# 传输层

## 1. 端口和套接字

## 1.1 端口

* 标志计算机中进程与运输层交互的接口
* 16位：0-65535
* 分类：
  * 服务器端：
    * 0-1023：已为一些重要应用分配的端口号，如tomcat-80、https-443、ftp-20/21
    * 1024-49151（1011111111111111），用户为停用程序指定的端口号
  * 客户端：
    * 49152-65535（1011111111111111-（1111111111111111））,客户端socket自动获得，连接结束后就释放此端口

### 1.2 套接字

* IP+端口

## 2. 重要协议

* TCP
* UDP

## 3. TCP

### 3.1 TCP的特点

1. 面向连接（虚连接）

   * 软件层面进行连接，底层并不对连接提供支持

2. 可靠传输

   * 可保证向上层交付的数据的无差错、不丢失、不重复、不失序

3. 面向字节流

   * TCP把应用程序交下来的数据堪称仅仅是一连串的无结构的字节流
   * 流：流入到进程或从进程流出的字节序列

4. 双全工通信

   * 发送数据个接收数据可以同时进行
   * TCP两端设有发送缓存和接收缓存，用来临时存放数据。应用层把数据交给TCP之后，就可以做其他工作了。TCP把数据保存在缓存中，在合适的时间把数据发送出去。接收方也是一样，接收到之后放入缓存，上层在合适的时间从缓存取出数据
   * 发送缓存：准备发送的数据+已发送但未确认接收的数据
   * 接收缓存：按序到达但未被上层接收的数据+不按序到达的数据

5. 点到点

   * 一条tcp连接只能有两个端点

   ![1598335474658](imgs\1598335474658.png)

### 3.2 TCP数据报格式

![1598336518555](imgs\1598336518555.png)

* 源端口号：源主机ip+端口号
* 目的端口号：目的主机ip+端口号
* 序列号：seq，表示发送端在这个报文段的第一个数据字节的顺序号
* 确认号：ack，表示接收端期望收到的下一个序列号，是上次成功接收到的数据段的左后一个数据字节顺序号+1
* 首部长度（数据偏移）：TCP报文首部是可变的，常为20字节
* 保留位：暂留，置为0
* 控制位：
  * URG：表示紧急数据
  * ACK：1表示此报文包含确认信息，0表示不包含确认信息，忽略确认号
  * PSH：表示将此报文尽快交给应用层，无需等待缓冲区满
  * RST：用于复位由于主机崩溃或其它原因而出现错误的连接。它还可以用于拒绝非法的报文段和拒绝连接的请求，一般情况下，如果收到一个RST
    为1的报文，那么一定发生了某些问题。
  * SYN：连接请求，发送连接请求和确认连接请求时为1
  * FIN：释放请求，发送释放请求和确认释放请求时为1
* 窗口大小：窗口值告诉对方：从本报文段首部中的确认号算起，接收方目前允许对方发送的数据量。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。总之，窗口值作为接收方让发送方设置其发送窗口的依据。
* 校验和：此校验和是对整个的TCP报文段，包括TCP头部和TCP数据，以16位字进行计算所得。这是一个强制性的字段，一定是由发送端计算和存储，
  并由接收方进行验证
* 紧急指针：只有URG标志置为1时紧急指针才有效，TCP的紧急方式是发送端向另一端发送紧急数据的一种方式。
* 选项：最常见的可选字段是最长报文大小，它指明本端所能接收的最大长度的报文段
* 数据：应用层传下来的数据，进行分组后

### 3.3 三次握手/4次挥手

#### 3.3.1 三次握手



![1598339086469](imgs\1598339086469.png)

* 首先服务器进程先创建传输控制模块TCB，时刻准备客户端进程的连接请求，此时服务器进入LISTEN（监听状态）
  1. **第一次握手：**客户端进程也是先创建传输控制模块TCB，然后向服务器发送连接请求报文：同步标志位**SYN=1**，选择一个随机初始序列号**seq=x**，客户端进入**SYN-SENT**（同步已发送状态）。TCP规定SYN=1报文段不能携带数据，但需要消耗掉一个序列号。
  2. **第二次握手：**服务器收到请求报文后，如果同意连接，则发出确认报文：**SYN=1,ACK=1(确认号有效)，ack=x+1（确认序号）**，同时自己也初始化一个序列号**seq=y**；此时服务器进程进入了**SYN-RCVD**（同步收到状态），这个报文同样不能携带数据，但要消耗一个序列号。
  3. **第三次握手：**客户端进程给服务器返回确认的确认，确认报文为：ACK=1(确认号有效)，ack=y+1（确认号），**seq=x+1**（发送序列号）。此时TCP连接已建立，客户端进入**ESTABLISHED**状态，当服务器收到客户端的确认后，也进入**ESTABLISHED**状态。

#### 3.3.2 四次挥手

![1598339133344](imgs\1598339133344.png)

1. 客户端发出连接释放报文：FIN=1,序列号seq=u（等于前面已经传送过来的数据的最后一个字节+1），客户端进入FIN-WAIT-1(终止等待1)。TCP规定，FIN报文段不携带数据，也要消耗一个序号。

2. 第二次挥手：服务器收到连接释放报文，发出确认报文：ACK=1（确认序号有效），ack=u+1（确认序号），并且带上自己的序列号seq=v，此时服务端就进入了CLOSE-WAIT（等待关闭状态）。

   ​		服务器通知应用进程，客户端向服务器的方向释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器要发送数据，客户
   端依然接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT时间。
   客户端收到服务器的确认请求后，此时客户端就进入了FIN-WAIT-2(终止等待状态)，等待服务器发送连接释放报文（在这之前还可接受服务器发送
   的最终数据）	

3. 在服务器最后的数据发送完后，发送连接释放报文：FIN=1,ACK=1(确认有效)，ack=u+1（确认号），由于处于半关闭状态，服务器很可能又发送了一些数据，假定此时序列号为seq=w；服务器就进入了LAST-ACK（最后确认状态），等待客户端确认。

4. 客户端在收到服务器的连接释放报文后，必须发出确认：ACK=1,ack=w+1，自己的序列号seq=u+1，此时客户端就进入了TIMEWAIT(时间等待)状态。注意此时TCP连接并没有释放，必须经过2*MSL（最长报文寿命）的时间后，当客户端撤销相应的TCB后，进入CLOSED状态。

   服务器只要收到了客户端发出的确认，立即进入CLOSED状态，可以看到服务器结束TCP连接比客户端早一些。

#### 3.3.3 连接时握手两次和四次的缺点

* 两次缺点：防止失效的连接请求又传到了服务器导致出现多次连接错误
  * 场景描述：客户端发送了连接请求，网差，请求卡在了半路；客户端迟迟没有接受到服务端接收到请求的消息，又发了一次请求；服务端接收到了第二次的，发送了确认消息，客户端也接收到了，建立连接，发送数据，断开连接；此时第一次发送的连接又发送到了服务端，就会再次建立起连接，导致不必要的错误
* 四次缺点：三次足够了，四次多余

#### 3.3.4 断连时为什么等待2 * MSL

* MSL（Maximum Segment LifeTime），TCP允许不同的实现可以设置不同的MSL值
* 第一，保证客户端发送的是最后一个ACK报文能够到达服务器，避免服务器端收不到最终确认信息。服务器端接收不到结果后，重发第三次回收的数据报，客户端在这个2 * MSL时间内收到后会，重置等待时间2 * MSL
* 第二，防止了超时重传的数据又被接收到，因为等待的这2 * MSL时间内能保证之前发的数据都已经失效了

#### 3.3.5 为什么建立是三次，撤销时四次

* 发送时，服务端开始处于listen状态，接收到客户端的SYN信号后，将SYN和ACK信号在同一个报文中返回了
* 关闭时，服务器和客户端处于正常发数据状态，客户端发出FIN表示想断开，但仍然能接受数据；服务端先回复已接收ACK信号，但此时不能断开连接，因为还有一些未处理完的数据要发送，发送完数据后表示可以断开连接了，发送FIN信号给客户端。因此比建立时多了一次。

#### 3.3.6 如果建立了连接，但客户端故障了怎么办

* 服务端保有一个客户端保活计时器，每次收到客户端的请求都会重置计时器。计时器到达2小时后，服务端每隔75分钟给客户端发送试探，连续10次没响应，就关闭了

### 3.4 TCP可靠传输

#### 3.4.1 数据分割成块

* 在建立连接时，双方约定最大长度作为发送的单位，重传也以这个单位进行重传
* 理想情况下此大小正好不被网络层分块

#### 3.4.2 数据校验

* TCP使用伪首部对整个数据（头部+数据）进行验证

  ![1598359271177](imgs\1598359271177.png)

#### 3.4.3 序列号/确认应答机制

![1598422625594](imgs\1598422625594.png)

#### 3.4.4 超时重传

![1598422935272](imgs\1598422935272.png)

#### 3.4.5 连接管理

* 三次握手+四次挥手

#### 3.4.6 流量控制

##### 滑动窗口

![1598423104206](imgs\1598423104206.png)

![1598423179107](imgs\1598423179107.png)

![1598423268607](imgs\1598423268607.png)

##### 滑动窗口应答包和数据报丢失的处理

* 应答包丢失

![1598424098137](imgs\1598424098137.png)

![1598424187485](imgs\1598424187485.png)

* 数据包丢失

![1598424519240](imgs\1598424519240.png)

##### 流量控制

![1598424617716](imgs\1598424617716.png)

![1598424661650](imgs\1598424661650.png)

#### 3.4.7 拥塞控制

![1598424777097](imgs\1598424777097.png)

![1598424810583](imgs\1598424810583.png)

![1598424838937](imgs\1598424838937.png)

### 3.5 TCP提高性能的机制

* 滑动窗口

* 快速重传

  ![1598425174050](imgs\1598425174050.png)

* 延迟应答

  ![1598426946539](imgs\1598426946539.png)

* 捎带应答

  ![1598427438489](imgs\1598427438489.png)

### 3.6 如何看待面向字节流？缓冲区？

![1598427653762](imgs\1598427653762.png)

## 4. UDP

### 4.1 UDP的特点

1. 无连接
	* 减少开销和发送数前的时延	
2. 最大努力交付
	* 不保证可靠交付
3. 面向报文
	* UDP直接在应用层传递下来的报文上加上首部，交给网络层。要注意应用层向下传递的报文的大小
4. 无阻塞控制
	* 网络的阻塞不会影响UDP发送效率，常用在要求主机恒速发送数据，并允许在一定情况下丢失一部分数据的情况，直播等
5.  首部开销小
	* 8个字节
6. 支持一对一、一对多、多对一、多对多

### 4.2 UDP报文格式

四个字段，每个字段占用2个字节

| 源端口 | 目的端口 | 长度 | 检验和 |


* 源端口：源端口号，在需要对方回信时选用，不需要可选为0000000000000000
* 目的端口：目的端口号，在终点主机解析时对应应用进程
* 长度：UDP数据报（UDP首部+数据）总字节数，最小为8，仅有首部
* 检验和：在终点时检验用户数据报在传输中是否有错，有错则丢弃

![1598333984405](imgs\1598333984405.png)





























