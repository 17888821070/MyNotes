# 应用层

## 1. [主要协议](https://blog.csdn.net/mellymengyan/article/details/51115521)

### 1.1 文件传输协议（FTP）

* 通信方式：TCP

* 服务端口：控制端口21、数据端口20

  ![img](imgs\20160410220257118)

* 概述

  * 文件传输协议，负责将文件从一台计算机传送到另一台计算机上，并且保证其传输的可靠性。
    客户端提出文件传输请求，服务器接收请求并提供服务。首先在本地计算机上启动FTP客户程序，利用他与远程计算机建立连接，远程计算机上的服务端FTP程序被激活。这样本地的FTP程序成为一个客户，而远程FTP程序成为服务器，他们之间通过TCP建立连接，端口号为21.
  * FTP协议的客户机与服务器之间需要建立两个连接， 一个用于控制数据传输（端口21）， 一个用于数据传输（端口20）。数据连接主要用于数据传输，完成文件内容的传输。控制连接主要用于传输FTP控制命令和服务器的回送消息。

* 功能

  * 1：可以从本地上传和从服务器下载文件；
    2：能够传输各种类型的文件，包括文件，图片， 视频等；
    3：能够提供对本地和远程计算机的目录操作。
    4：对文件进行改名删除等操作。	

### 1.2 远程控制协议（**TELNET** ）

* 通信方式：TCP
* 服务端口：23

* 通信过程

  * 用户的终端实际上与本地的TELNET客户机程序进行通信，远程主机与远程TELNET服务器进行通信。然后通过TCP进行连接， 客户机与服务器之间采用NVT标准进行通信。

    1：建立与服务器的TCP连接；
    2：从键盘上接收用户输入的字符；
    3：把用户输入的字符串变成标准格式并送给服务器；
    4：从远程服务器接收输出的信息；
    5：把该信息显示在用户的屏幕上。

### 1.3 邮件传输协议（SMTP）

* 通信方式： TCP
* 服务端口：25
* 工作方式：
  基于客户/服务器方式进行的。发送人的主机为客户方，收件人的邮件服务器为服务方。在传送邮件的过程中，需要使用TCP协议进行连接（默认端口号为25）。发送主机先将邮件发送到本地SMTP服务器上，本地SMTP服务器与接收方的邮件服务器建立可靠的TCP连接，从而保证了邮件传输的可靠性。

![img](imgs\20160410220026586)

### 1.4 Http协议
* 通信方式：TCP
* 服务端口：80

* 

### 1.5 DNS解析协议

* 通信方式：UDP

* 默认端口：53

* 作用：

  用域名系统来处理IP地址和主机名之间的转换， 在DNS中主机名即为域名。
  DNS也是一个应用层协议，为了提供主机名到IP地址的转换服务，DNS是运行在UDP协议之上，使用53号端口。

* 查询方式

  **1：递归解析：**
  当收到请求时， 域名服务器应返回所要求的解析结果，不论该服务器是否有相关的信息。该服务器没有相关信息时， 那么就该向其他的服务器进行请求，直到获得结果或者错误信息，然后把结果返回给解析请求者。

  **2：重复解析：**
  接收到请求时， 域名服务器若有该域名的相关信息，则返回IP地址给解析请求者。若无该域名的相关消息，则该服务器不再进一步向其他域名服务器请求解析，而是返回一个可用的域名服务器的地址给解析请求者，让解析请求这自己去向该域名服务器作进一步的解析请求。

## 2. HTTP协议

### 2.1 网站通信过程

1. DNS域名解析，请求域名服务器，获取域名对应主机ip
2. 封装HTTP请求数据包
3. 封装成TCP包并建立连接
4. 客户机发送请求命令
5. 服务器生成HTTP响应数据包
6. 服务器关闭TCP连接
   - 此处可以在响应字段中加入Connection:keep-alive，不关闭TCP连接

### 2.2 请求数据包格式

组成：
* 报文首部
    * 请求行
        * 请求方式
        * 请求的资源名称
        * HTTP协议版本号
    * 首部字段（举例）
        * Accept: text/html,image/*    【浏览器告诉服务器，它支持的数据类型】
        * Accept-Charset: ISO-8859-1    【浏览器告诉服务器，它支持哪种字符集】
        * Accept-Encoding: gzip,compress 【浏览器告诉服务器，它支持的压缩格式】
        * Accept-Language: en-us,zh-cn 【浏览器告诉服务器，它的语言环境】
        * Host: www.it315.org:80【浏览器告诉服务器，它的想访问哪台主机】
        * If-Modified-Since: Tue, 11 Jul 2000 18:23:51 GMT【浏览器告诉服务器，缓存数据的时间】
        * Referer: http://www.it315.org/index.jsp【浏览器告诉服务器，客户机是从那个页面来的---反盗链】
        * 8.User-Agent: Mozilla/4.0 (compatible; MSIE 5.5; Windows NT 5.0)【浏览器告诉服务器，浏览器的内核是什么】
        * Cookie【浏览器告诉服务器，带来的Cookie是什么】Connection: close/Keep-Alive  【浏览器告诉服务器，请求完后是断开链接还是保持链接】
        * Date: Tue, 11 Jul 2000 18:23:51 GMT【浏览器告诉服务器，请求的时间】
* 空行
* 报文主体

### 2.3 请求

### 2.4 响应



### 2.3 响应数据包格式

组成：
* 报文首部
    * 状态行
        * HTTP版本
        * 状态码
        * 原因描述
    * 首部字段（举例）
        * Location: http://www.it315.org/index.jsp 【服务器告诉浏览器要跳转到哪个页面】
        * Server:apache tomcat【服务器告诉浏览器，服务器的型号是什么】
        * Content-Encoding: gzip 【服务器告诉浏览器数据压缩的格式】
        * Content-Length: 80 【服务器告诉浏览器回送数据的长度】
        * Content-Language: zh-cn 【服务器告诉浏览器，服务器的语言环境】
        * Content-Type: text/html; charset=GB2312 【服务器告诉浏览器，回送数据的类型】
        * Last-Modified: Tue, 11 Jul 2000 18:23:51 GMT【服务器告诉浏览器该资源上次更新时间】
        * Refresh: 1;url=http://www.it315.org【服务器告诉浏览器要定时刷新】
        * Content-Disposition: attachment; filename=aaa.zip【服务器告诉浏览器以下载方式打开数据】
        * Transfer-Encoding: chunked  【服务器告诉浏览器数据以分块方式回送】
        * Set-Cookie:SS=Q0=5Lb_nQ; path=/search【服务器告诉浏览器要保存Cookie】Expires: -1【服务器告诉浏览器不要设置缓存】
        * Cache-Control: no-cache  【服务器告诉浏览器不要设置缓存】
        * Pragma: no-cache   【服务器告诉浏览器不要设置缓存】
        * Connection: close/Keep-Alive   【服务器告诉浏览器连接方式】
        * Date: Tue, 11 Jul 2000 18:23:51 GMT【服务器告诉浏览器回送数据的时间】
* 空行
* 报文主体

### 2.4 请求方式

HTTP提供方法的目的就是为了告知服务器该客户端想进行什么操作
GET ：请求读取有URL所标志的信息
POST ：给服务器添加信息
HEAD ：请求读取由URL所标志的信息的首部
PUT ：在指定URL下存储一个文档
DELETE ：删除指定RUL所标志的资源
OPTION ：请求一些选项信息
TRACE ：用来进行换回测试的请求报文

### 2.5 响应状态码

![1598440162624](imgs\1598440162624.png)

### 2.6 HTTP信息保存

HTTP是无状态的，也就是说，它是不对通信状态进行保存的。它并不知道之前通信的对方是谁。这样设计的目的就是为了让HTTP简单化，能够快速处理大量的事务！

但是，我们经常是需要知道访问的人是谁，于是就有了Cookie技术了。

- 要是服务器端想要记住客户端是谁，那么就颁发一个cookie给客户端
- 客户端把Cookie保存在硬盘中，当下次访问服务器的时候，浏览器会自动把客户端的cookie带过去。
- 就这样，服务器就能够知道这家伙是谁了。

### 2.7 持久连接

- HTTP1.0版本时，每进行一次HTTP通信都会新建、断开一次TCP连接。
- HTTP1.1版本，TCP改为持久连接，一次连接可以进行多次请求响应。实现了管线化，一次请求后不必须等待响应，就可以发送下一个请求

### 2.8 传输效率

- 主要针对报文主体部分
  1、压缩技术将报文压缩，客户端和服务端发送和接收时解压还原
  2、使用分块传输编码，一块一块传，如下载可以下次接着下载

## 3. HTTPS

### 3.1 HTTPS与HTTP的区别

* HTTPS需要申请CA认证，需要费用
* HTTPS数据进行加密处理，HTTP采用明文传送
* 默认端口不同，HTTPS是443，HTTP是80
* HTTPS采用SSL/TLS协议构建可加密传输、身份认证的网络协议，安全。HTTP是简单连接无状态

### 3.2 HTTPS建立连接请求的步骤

* 客户端请求连接服务器
* 服务器返回CA认证证书
* 客户端产生对称密钥
* 客户端使用服务器的公钥对对称密钥加密
* 客户端发发送加密后的对称密钥给服务器
* 服务器使用私钥解密得到对称密钥
* 客户端与服务端使用对称密钥对请求和响应报文进行加密解密传输数据

![1598442209645](imgs\1598442209645.png)

## 4 加密

#### 4.1 对称加密

* 加密密钥和级秘密钥是相同的密码体制

#### 4.2 公钥私钥加密

* 内容
  * 加密秘钥（公钥）和解密秘钥（私钥）不是一个
  * 公钥公开，私钥自己保存
  * 加密算法和解密算法公开
* 过程
  * 发送者A，接收者B
    1、密钥对产生器，产出接收者B的一对密钥（加密密钥_公开，解密密钥_私密）
    2、发送者A利用B的公开加密密钥和加密算法得到密文，发送给B
    3、接收者B接收到密文，使用自己的私密解密密钥和解密算法对密文进行解密，恢复出明文使用

* 特点
  * 从公钥推导解密私钥，计算机上不可能
  * 公钥不能用来解密
  * 任何加密方法的安全性取决于密钥的长度，以及攻破密文所需的计算量

### 4.3 数字签名

* 数字签名必须实现的功能
	* 接收者能够核实发送者对报文的签名（我收到你的消息，我要确信是你发的）
	* 接收者确信收到的数据和发送者发送的完全一样而没有被篡改过
	* 发送者时候不能抵赖对报文的签名
* 使用公钥方式实现数字签名
	1、签名：发送方用自己的私钥和解密算法对密文进行签名
	2、加密：发送方用对方的公钥和加密算法对签字的密文进行加密
	3、解密：接收方用自己的私钥和解密算法对密文进行解密
	4、确认：接收方用对方的公钥和加密算法对密文进行签名确认

	![1598442758627](imgs\1598442758627.png)
	

### 4.4 秘钥分配

* 对称密钥分配
     * 密钥分配中心KDC
 用户A和用户B，在KDA登记，登记时确定和KDC进行通信的主密钥KA和KB
 ![1598442857351](imgs\1598442857351.png)
     * 步骤
		1. 用户A向密钥分配中心KDC发送时用明文，说明想和用户B通信。在明文中给出A和B在KDC登记的身份。
		2. KDC用随机数产生“一次一密”的会话密钥 KAB供A和B的这次会话使用，然后向A发送回答报文。这个回答报文用A的密钥 KA加密。这个报文中包含有这次会话使用的密钥KAB和请A转给B的一个票据(ticket)[插图]，它包含A和B在KDC登记的身份，以及这次会话将要使用的密钥KAB。这个票据用B的密钥KB加密，因此A无法知道此票据的内容，因为A没有B的密钥KB。当然A也不需要知道此票据的内容。
		3. 当B收到A转来的票据并使用自己的密钥KB解密后，就知道A要和他通信，同时也知道KDC为这次和A通信所分配的会话密钥KAB。

* 公钥分配
  * 认证中心CA
  * 认证中心CA的公钥所有用户都可以获得
   * 步骤
        * 用户想要验证某个公钥是否是某个个体所拥有，向CA机构查询
        * CA机构给用户发送用CA签名的证书，用户用CA的公钥对证书进行验证
  
  