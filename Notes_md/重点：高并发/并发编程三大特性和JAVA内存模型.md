# JAVA内存模型JMM

## 1、计算机硬件级别内存模型

![1602512161646](img\1602512161646.png)

## 2、Java内存模型

![1602512349141](img\1602512349141.png)

> * 每个线程都有一个工作内存
> * 共享变量在主内存
> * 每个线程操作共享变量时，先将主内存的变量拷贝到工作内存得到一个副本

## 3、Java内存模型定义的原子操作

| 原子操作 | 作用 | 详细描述                           | |
| -------- | ---- | --------------------- |---- |
| lock     | 锁定 | 主内存变量加锁，标识位线程独占状态 |	|
| read     | 读取 | 读取主内存数据                     |	|
| load     | 载入 | 载入到工作内存                     |	|
| use      | 使用 | 使用工作内存中的数据               |	|
| assign   | 赋值 | 修改后给工作内存的数据赋值         |	|
| store    | 存储 | 将工作内存中的数据传入主内存       |	|
| write    | 写入 | 将store传来的数据赋值给主内存变量  |	|
| unlock   | 解锁 | 主内存变量解锁                     |	|

![](img\1602513980416.png)

* 解决同步问题的方法

> * 总线加锁（效率低）
>
>   ​	在有线程读取了共享变量后，对主内存进行加锁，其他线程无法读取主内存数据，直到线程write之后释放锁
>
> * 缓存一致性协议
>
>   	1. 每个线程使用自己工作内存的副本进行操作
>    	2. 当有线程执行了store操作时，会将其他线程的工作内存的副本置为失效
>    	3. 各线程发现副本失效后，就去主线程拿新数据



# 并发编程三大特性

## 原子性

* 一个操作或多个操作，要么都执行，不会被打断，要么都不执行
![1602516190932](img\1602516190932.png)
number++不是原子操作，某一个线程改变了内存值之后，其他线程不一定知道改变，仍然读取了高速缓存中的旧值，计算后写入到内存，其实就相当一第一个线程的修改无效了

## 可见性

* 可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。
```java
//线程1执行的代码
int i = 0;
i = 10;
 
//线程2执行的代码
j = i;
```
假若执行线程1的是CPU1，执行线程2的是CPU2。由上面的分析可知，当线程1执行 i =10这句时，会先把i的初始值加载到CPU1的高速缓存中，然后赋值为10，那么在CPU1的高速缓存当中i的值变为10了，却没有立即写入到主存当中。

此时线程2执行 j = i，它会先去主存读取i的值并加载到CPU2的缓存当中，注意此时内存当中i的值还是0，那么就会使得j的值为0，而不是10.

这就是可见性问题，线程1对变量i修改了之后，线程2没有立即看到线程1修改的值。

## 有序性

* java在编译和云心是会对代码进行优化，会导致程序最终的执行顺序不一定是编写代码时的顺序
重排的代码需要没有数据依赖关系
```java
int a = 0; //语句1
int b = 1; //语句2

b= a;      //语句3
a++;       //语句4
```
语句1和语句2可能会被重排，语句三不会排到12前面，4也不会排到123前面
能够保证单线程的结果
但在多线程中可能会有问题

```java
共享变量
int a = 0;
boolean flag = false
//线程1
a = 10;
flag = true;

//线程2
while(!flag){

}
int b = a*a;
```
当线程1被重排后，线程2跳出循环时获取的a的数值可能是错误的，计算得到的b可能是错的