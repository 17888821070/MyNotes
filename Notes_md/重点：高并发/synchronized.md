## sychronized

### 作用

> 保证共享变量的同步安全

### 用法

> * 修饰代码块
>
> * 修饰普通方法
> * 修饰静态方法

### 三种用法的区别

> 修饰代码块，锁住的是调用方法的对象（堆区）
>
> 修饰普通方法，锁住的是调用方法的对象（堆区）
>
> 修饰静态方法，锁住的是类的Class对象（堆区）

## synchronized保证线程同步的原理

> 1、synchronized会在代码块开始和结束的时候加入字节码指令monitorenter和monitorexit或者给同步方法加上acc_synchronized标识符
>
> 2、monitor是实际的对象监视锁，是一个C++类对象，存放在堆区对象的对象头中
>
> 3、monitorenter表示进入monitor，monitorexit表示退出monitor，同一时刻只有一个线程可以获取到monitor
>
> ​	<font color="red">保证了原子性，因为同一时间只有一个线程可以执行共享变量的操作，所以每个代码块就是原子的</font>
>
> ​	<font color="blue" >保证了有序性，因为将多线程并行对共享变量的操作退化成了多线程串行的操作，单线程内的指令重排不会引起最终结果的错误</font>
>
> 4、加上Monitor的原理

## monitor的原理

> monitor是一个C++类ObjectMonitor的对象，类属性如图

![1602551431918](img\1602551431918.png)

> ### OnjectMonitor关键属性
>
> ​	_owner：持有ObjectMonotor对象的线程
>
> ​	_Waitset：存放处于wait状态的线程队列
>
> ​    _EntryList：存放处于等待锁block状态的线程队列
>
> ​	_recursions：锁的冲入次数
>
> ​	_count：线程获取锁的次数
>
> ### monitor执行流程
>
> ​	1、当多线程同时执行同一个代码块时，所有线程都进入entryList
>
> ​	2、某个线程获取到锁：onwer设置为获取到锁的线程，_recursions++
>
> ​	3、拥有锁资源的线程执行完同步代码块，owner置为null，_recursions--，其他线程进行锁的获取
>
> ​	4、拥有锁资源的线程执行了wait方法，owner置为null，_recursions--，此线程加入Waitset，等待唤醒
>
> ![1602552618064](img\1602552618064.png)

## Markword层次解释锁升级

* Markword：是对象头中的主要部分

  扩展：对象头{}

![img](img\8a6b3fdd3dc8.png)

![img](F:\Users\LZX\Desktop\MyNote\MyNotes_html\MyNotes\Notes_md\重点：高并发\img\8fca8bd7b00e.png)

### 偏向锁

> **使用场景：**只有一个线程会获取锁资源
>
> **描述：**当一个线程要获取锁资源，并且锁资源之前未被获取过时，对象的锁就是偏向锁
>
> **记录内容：**markword中记录偏向锁的线程指针，锁状态标记1 01
>
> **锁升级：**
>
> ​	新线程与记录线程一致，保持偏向锁
>
> ​	新线程与记录线程不一致，锁升级

#### 轻量级锁

> **使用场景：**如果一个对象虽然有多线程要加锁，但加锁的时间是错开的（也就是没有竞争），那么可以 使用轻量级锁来优化。 
>
> **描述：**当一个线程要获取锁资源，发现偏向锁的线程记录已经由一个不一致的线程，并且未在运行，就升级位轻量级锁
>
> **记录内容：**正在执行的线程或者无线程，锁状态标记0 00
>
> **锁升级：**
>
> ​	cas当前线程(无线程，新入线程)
>
> ​		成功：仍然为轻量级锁
>
> ​		失败：进入自旋锁

#### 自旋锁

> **使用场景：**其他锁类型升级为重量级锁类型的过度
>
> **描述：**当一个线程要获取锁资源，发生了cas修改当前线程失败的情况，会进行10次自旋，如果都失败了才会进入重量级锁

#### 重量级锁

> **使用场景：**锁冲突比较严重，多次cas自旋操作都没获取到锁，进入阻塞状态
>
> **记录内容：**正在执行的线程或者无线程，锁状态标记0 10

![img](img\79082c168ea2.png)