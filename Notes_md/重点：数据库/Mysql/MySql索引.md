[目录](目录.md)

# 索引

## 1.  索引的创建和删除

* 创建索引

  ```mysql
  -- 直接创建索引
  create [索引类型] 索引名 on 表名(字段名(长度))
  create unique index MyIndex on MyTable(cardNumber(10)) -- 例子
  
  -- 修改表 
  alter table 表名 add [索引类型] index 索引名(字段名(长度))
  alter table MyTable add unique index MyIndex(cardNumber(10))-- 例子
  
  -- 创建表时，加入索引
  create table 表名(
  	 [索引类型] index (字段1,字段2)}
  )
  create table 表名(){			--例子
  	 unique index (name,cardNumber)
  }
  
  
  -- 索引类型
  -- 1. 普通索引 index
  -- 2. 唯一索引 unique index
  -- 3. 全文索引 fulltext index
  -- 4. 组合索引 index 索引名(字段1，字段2)
  ```

* 删除索引

  ```mysql
  -- 直接删除 
  drop [索引类型] index 索引名 on 表名
  
  -- 修改表删除
  alter table 表名 drop [索引类型] index 索引名
  ```

## 2. 索引数据结构

### 2.1 B+树

* 多叉树
* 让数据维持在3-5层
* 每次IO一个page大小，一个page16KB，当一个节点的key值为8Byte时，就可以分支出16*1024/8个分支
* 子节点中包含父节点
* 叶子节点存索引和对应的数据
* 叶子节点形成了链表，指向下一个叶子节点
* 稳定，怎么都是IO树的高度次

### 2.2 Page

* page是InnoDB磁盘管理的最小单位，与数据库相关的所有内容都存储在这种page结构中

  > - **各个数据页**可以组成一个**双向链表**
  >
  > - 而**每个数据页中的记录**又可以组成一个**单向**链表
  >
  > - - 每个数据页都会为存储在它里边儿的记录生成一个**页目录**，在通过**主键**查找某条记录的时候可以在页目录中使用**二分法快速定位**到对应的槽，然后再遍历该槽对应分组中的记录即可快速找到指定的记录
  >   - 以**其他列**(非主键)作为搜索条件：只能从最小记录开始**依次遍历单链表中的每条记录**。

* 所有的数据叶是双向链表，page中的数据是单项链表
  * 条件是普通字段（非索引数据）时
    * 遍历所有page的所有数据
  * 条件是索引字段时
    * 根据存根节点数据的page找到第二层的精确的一个page，直到找到叶子page，遍历数据



## 3. 索引类型（逻辑分类）

* 主键索引
* 常规非主键索引
* 唯一索引
* 符合索引
* 前缀索引
*  全文索引
* 外键索引
* 覆盖索引

## 4. 索引类型（叶子节点数据分类）

* 聚集索引

  1、叶子结点数据存储的是行数据
  2、索引和数据存储在一起
  3、建议使用int型自增的字段作为主键

  ​	-> int型是为了保证维护B+树时比较的方便性

  ​	-> 自增是为了防止在前面插入数据时需要调整B+树结构

* 非聚集索引

  1、索引文件和数据文件不是同一个文件，分别对应.MYI和.MYD文件
  2、索引B+树的叶子结点的数据存放的是真正数据在磁盘的的是指针或者主键值

## 5. 索引提高检索速度，降低插入修改速度

* 提高检索速度
  * 能够通过B+树索引精准的找到page，在最后的page中遍历找到数据
* 降低插入修改速度
  * 插入修改时，会破坏索引文件的B+树平衡性，需要额外的开销使索引树平衡

## 6. Hash索引

* 优点：
  * 检索非常快
* 缺点
  * 没办法范围查找
  * 没办法最左匹配原则
  * 键重复情况Hash冲突频率高
  * 没办法利用索引排序

## 7. 最左匹配原则

- 索引可以简单如一个列 `(a)`，也可以复杂如多个列 `(a,b,c,d)`，即**联合索引**。
- 如果是联合索引，那么key也由多个列组成，同时，索引只能用于查找key是否**存在（相等）**，遇到范围查询 `(>、<、between、like`左匹配)等就**不能进一步匹配**了，后续退化为线性查找。
- 因此，**列的排列顺序决定了可命中索引的列数**。

例子：

- 如有索引 `(a,b,c,d)`，查询条件 `a=1 and b=2 and c>3 and d=4`，则会在每个节点依次命中a、b、c，无法命中d。(c已经是范围查询了，d肯定是排不了序了)

为什么能命中c？

举个简单例子： `select * from user where age>30;` 如果在age列创建索引，那你说会走索引吗？

## 8. = in 自动优化顺序

**不需要考虑=、in等的顺序**，mysql会自动优化这些条件的顺序，以匹配尽可能多的索引列。

例子：

- 如有索引 `(a,b,c,d)`，查询条件 `c>3 and b=2 and a=1 and d<4`与 `a=1 and c>3 and b=2 and d<4`等顺序都是可以的，MySQL会自动优化为 `a=1 and b=2 and c>3 and d<4`，依次命中a、b、c。

